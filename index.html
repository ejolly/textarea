<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#1c1c1e">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: dark;
    background: #1c1c1e;
    color: #f5f5f7;
  }

  article {
    outline: none;
    padding: 24px max(24px, calc(50vw - 360px));
    width: 100%;
    min-height: 100dvh;
    font: 20px/1.65 Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-feature-settings: "cv01", "cv02", "cv03", "cv04";
    letter-spacing: -0.01em;
    tab-size: 4;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    white-space: pre-wrap;
    text-wrap-style: pretty;
    overflow-wrap: break-word;
    caret-color: #ffd60a;
  }

  /* Placeholder for empty state */
  article:empty::before {
    content: "Start writing...";
    color: #48484a;
    pointer-events: none;
  }

  /* Selection styling */
  ::selection {
    background: rgba(255, 214, 10, 0.3);
  }

  /* Scrollbar styling */
  ::-webkit-scrollbar {
    width: 8px;
  }
  ::-webkit-scrollbar-track {
    background: transparent;
  }
  ::-webkit-scrollbar-thumb {
    background: #3a3a3c;
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background: #48484a;
  }

  /* Markdown content styling via CSS Custom Highlight API
     Note: Only color, background-color, and text-decoration are supported. */

  ::highlight(md-heading) {
    color: #f5f5f7;
  }

  ::highlight(md-bold) {
    color: #e5e5e5;
  }

  ::highlight(md-italic) {
    color: #a1a1a6;
  }

  ::highlight(md-code) {
    background-color: rgba(99, 99, 102, 0.35);
  }

  ::highlight(md-codeblock) {
    background-color: rgba(99, 99, 102, 0.25);
  }

  ::highlight(md-strike) {
    text-decoration: line-through;
    color: #636366;
  }

  ::highlight(md-link) {
    color: #a1a1a6;
    text-decoration: underline;
  }

  ::highlight(md-marker) {
    color: #48484a;
  }

  ::highlight(md-blockquote) {
    color: #7c7c80;
  }

  ::highlight(md-hr) {
    color: #3a3a3c;
  }

  ::highlight(md-task-done) {
    text-decoration: line-through;
    color: #48484a;
  }

  /* Print styles */
  @media print {
    html {
      background: white;
      color: black;
    }
    article {
      padding: 0;
      min-height: auto;
    }
    article:empty::before {
      display: none;
    }
  }
</style>
<article contenteditable="plaintext-only" spellcheck></article>
<script>
  const article = document.querySelector('article')
  article.addEventListener('input', debounce(300, onInput))
  article.addEventListener('blur', save)
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault()
      download()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  // Check for CSS Custom Highlight API support
  const hasHighlightAPI = 'CSS' in window && 'highlights' in CSS

  // Decode URI-encoded hash (browsers percent-encode Unicode in location.hash)
  function getHash() {
    try {
      return decodeURIComponent(location.hash)
    } catch {
      return location.hash
    }
  }

  async function load() {
    try {
      if (location.hash !== '') await set(getHash())
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
        article.focus()
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
      article.focus()
    }
    updateTitle()
    if (hasHighlightAPI) highlightMarkdown()
  }

  function onInput() {
    save()
    if (hasHighlightAPI) highlightMarkdown()
  }

  async function save() {
    const hash = await get()
    if (getHash() !== hash) history.replaceState({}, '', hash)
    try { localStorage.setItem('hash', hash) } catch (e) {}
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    article.textContent = content
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1]?.trim() ?? 'Textarea'
  }

  // Base65536: Unicode-based encoding (~2 bytes per character vs base64's 0.75)
  // Encodes 16 bits per Unicode code point for ~40% shorter URLs
  // Source: https://github.com/qntm/base65536
  const base65536=function(r){"use strict";const o={},t={};["ã€ä´€ä¸€é¼€ê„€ê€ê”€ê˜€ð˜€ðœ€ð’€€ð’Œ€ð“€€ð“€ð”€ð”˜€ð– €ð–¨€ð €€ð¨˜€","á”€á˜€"].forEach(((r,n)=>{const e=16-8*n;o[e]={};let c=0;r.match(/../gu).forEach((r=>{const[n,f]=[...r].map((r=>r.codePointAt(0)));for(let r=n;r<f;r++){const n=String.fromCodePoint(r),f=16===e?c%256*256+(c>>8):c;o[e][f]=n,t[n]=[e,f],c++}}))}));return r.decode=r=>{const o=r.length,n=new Uint8Array(Math.floor(16*o/8));let e=0,c=0,f=0,a=!1;for(const o of r){if(a)throw new Error("Secondary character found before end of input");if(!(o in t))throw new Error(`Unrecognised Base65536 character: ${o}`);const[r,i]=t[o];for(let o=r-1;o>=0;o--){c=(c<<1)+(i>>o&1),f++,8===f&&(n[e]=c,e++,c=0,f=0)}16!==r&&(a=!0)}if(c!==(1<<f)-1)throw new Error("Padding mismatch");return new Uint8Array(n.buffer,0,e)},r.encode=r=>{const t=r.length;let n="",e=0,c=0;for(let f=0;f<t;f++){const t=r[f];for(let r=7;r>=0;r--){e=(e<<1)+(t>>r&1),c++,16===c&&(n+=o[c][e],e=0,c=0)}}if(0!==c){for(;!(c in o);)e=1+(e<<1),c++;n+=o[c][e]}return n},r}({});

  // Compression: Brotli with fallback to deflate-raw
  // Format prefixes:
  //   '0' = deflate-raw + base64url (legacy)
  //   '1' = brotli + base64url (legacy)
  //   '2' = brotli + base65536 (~40% shorter URLs)
  //   '3' = deflate-raw + base65536 (fallback when brotli unavailable)
  //   no prefix = legacy deflate-raw + base64url
  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    let format = 'deflate-raw', prefix = '3'

    // Try Brotli if available
    try {
      new CompressionStream('br')
      format = 'br'
      prefix = '2'
    } catch {}

    const stream = new CompressionStream(format)
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return prefix + base65536.encode(new Uint8Array(buffer))
  }

  async function decompress(data) {
    if (!data) return ''

    // Detect format from prefix
    let format = 'deflate-raw'
    let encoded = data
    let useBase65536 = false

    if (data[0] === '2') {
      format = 'br'
      encoded = data.slice(1)
      useBase65536 = true
    } else if (data[0] === '3') {
      format = 'deflate-raw'
      encoded = data.slice(1)
      useBase65536 = true
    } else if (data[0] === '1') {
      format = 'br'
      encoded = data.slice(1)
    } else if (data[0] === '0') {
      format = 'deflate-raw'
      encoded = data.slice(1)
    }
    // No prefix = legacy deflate-raw format (backwards compatibility)

    const byteArray = useBase65536
      ? base65536.decode(encoded)
      : Uint8Array.fromBase64(encoded, {alphabet: 'base64url'})

    const stream = new DecompressionStream(format)
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  // CSS Custom Highlight API for markdown rendering
  function highlightMarkdown() {
    // Clear existing highlights
    CSS.highlights.clear()

    // Build text and position map, accounting for <br> elements
    // which contribute newlines visually but not in textContent
    const nodePositions = []
    let text = ''

    function walkNodes(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        nodePositions.push({ node, start: text.length, end: text.length + node.length, type: 'text' })
        text += node.textContent
      } else if (node.nodeName === 'BR') {
        // BR elements contribute a newline to the logical text
        nodePositions.push({ node, start: text.length, end: text.length + 1, type: 'br' })
        text += '\n'
      } else if (node.childNodes) {
        for (const child of node.childNodes) {
          walkNodes(child)
        }
      }
    }
    walkNodes(article)

    if (!text || !nodePositions.length) return

    // Helper to find node and offset for a given text position
    function findPosition(pos) {
      for (let i = 0; i < nodePositions.length; i++) {
        const np = nodePositions[i]
        if (pos >= np.start && pos < np.end) {
          if (np.type === 'br') {
            // Position falls on a BR newline - use end of previous text node
            for (let j = i - 1; j >= 0; j--) {
              if (nodePositions[j].type === 'text') {
                return { node: nodePositions[j].node, offset: nodePositions[j].node.length }
              }
            }
            // No previous text node, use start of next text node
            for (let j = i + 1; j < nodePositions.length; j++) {
              if (nodePositions[j].type === 'text') {
                return { node: nodePositions[j].node, offset: 0 }
              }
            }
          }
          return { node: np.node, offset: pos - np.start }
        }
        // Handle position at exact end of this node
        if (pos === np.end && np.type === 'text') {
          return { node: np.node, offset: np.node.length }
        }
      }
      // Fallback to end of last text node
      for (let i = nodePositions.length - 1; i >= 0; i--) {
        if (nodePositions[i].type === 'text') {
          return { node: nodePositions[i].node, offset: nodePositions[i].node.length }
        }
      }
      return null
    }

    // Create range that works across multiple text nodes
    function createRange(startPos, endPos) {
      const range = new Range()
      const startInfo = findPosition(startPos)
      const endInfo = findPosition(endPos)
      if (!startInfo || !endInfo) return null
      range.setStart(startInfo.node, startInfo.offset)
      range.setEnd(endInfo.node, endInfo.offset)
      return range
    }

    // Highlight collections
    const markers = []
    const bold = []
    const italic = []
    const code = []
    const strike = []
    const heading = []
    const link = []
    const codeblock = []
    const blockquote = []
    const hr = []
    const taskDone = []

    // Patterns with capture groups for markers vs content
    const patterns = [
      // Code blocks (``` ... ```)
      {
        re: /```[^\n]*\n[\s\S]*?\n```/g,
        process: (match, start) => {
          const end = start + match.length
          const firstNewline = match.indexOf('\n') + 1
          const lastNewline = match.lastIndexOf('\n')
          // Opening ```
          markers.push(createRange(start, start + firstNewline))
          // Content
          if (lastNewline > firstNewline) {
            codeblock.push(createRange(start + firstNewline, start + lastNewline))
          }
          // Closing ```
          markers.push(createRange(start + lastNewline, end))
        }
      },
      // Inline code
      {
        re: /`([^`\n]+)`/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 1))
          code.push(createRange(start + 1, start + match.length - 1))
          markers.push(createRange(start + match.length - 1, start + match.length))
        }
      },
      // Bold **text**
      {
        re: /\*\*([^*\n]+?)\*\*/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 2))
          bold.push(createRange(start + 2, start + match.length - 2))
          markers.push(createRange(start + match.length - 2, start + match.length))
        }
      },
      // Strikethrough ~~text~~
      {
        re: /~~([^~\n]+?)~~/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 2))
          strike.push(createRange(start + 2, start + match.length - 2))
          markers.push(createRange(start + match.length - 2, start + match.length))
        }
      },
      // Italic *text* (but not **)
      {
        re: /(?<!\*)\*([^*\n]+?)\*(?!\*)/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 1))
          italic.push(createRange(start + 1, start + match.length - 1))
          markers.push(createRange(start + match.length - 1, start + match.length))
        }
      },
      // Headings # text
      {
        re: /^(#{1,6})[ \t]+(.*)$/gm,
        process: (match, start) => {
          const hashMatch = match.match(/^#{1,6}[ \t]/)
          const hashEnd = hashMatch ? hashMatch[0].length : match.indexOf(' ') + 1
          markers.push(createRange(start, start + hashEnd))
          heading.push(createRange(start + hashEnd, start + match.length))
        }
      },
      // Links [text](url)
      {
        re: /\[([^\]\n]+?)\]\(([^)\n]+?)\)/g,
        process: (match, start) => {
          const bracketEnd = match.indexOf(']')
          markers.push(createRange(start, start + 1)) // [
          link.push(createRange(start + 1, start + bracketEnd)) // text
          markers.push(createRange(start + bracketEnd, start + match.length)) // ](url)
        }
      },
      // Images ![alt](url)
      {
        re: /!\[([^\]\n]*?)\]\(([^)\n]+?)\)/g,
        process: (match, start) => {
          const bracketEnd = match.indexOf(']')
          markers.push(createRange(start, start + 2)) // ![
          link.push(createRange(start + 2, start + bracketEnd)) // alt text
          markers.push(createRange(start + bracketEnd, start + match.length)) // ](url)
        }
      },
      // Blockquotes > text
      {
        re: /^(>+)[ \t]?(.*)$/gm,
        process: (match, start) => {
          const markerMatch = match.match(/^>+[ \t]?/)
          const markerEnd = markerMatch ? markerMatch[0].length : 1
          markers.push(createRange(start, start + markerEnd))
          if (match.length > markerEnd) {
            blockquote.push(createRange(start + markerEnd, start + match.length))
          }
        }
      },
      // Horizontal rules (---, ***, ___)
      {
        re: /^[ \t]*([-*_])\1{2,}[ \t]*$/gm,
        process: (match, start) => {
          hr.push(createRange(start, start + match.length))
        }
      },
      // Unordered lists (- item, * item, + item)
      {
        re: /^([ \t]*)([-*+])[ \t]+/gm,
        process: (match, start) => {
          const indentMatch = match.match(/^[ \t]*/)
          const indent = indentMatch ? indentMatch[0].length : 0
          markers.push(createRange(start + indent, start + indent + 1)) // bullet
        }
      },
      // Ordered lists (1. item)
      {
        re: /^([ \t]*)(\d+\.)[ \t]+/gm,
        process: (match, start) => {
          const indentMatch = match.match(/^[ \t]*/)
          const indent = indentMatch ? indentMatch[0].length : 0
          const numMatch = match.match(/\d+\./)
          const numLen = numMatch ? numMatch[0].length : 2
          markers.push(createRange(start + indent, start + indent + numLen)) // number.
        }
      },
      // Task lists unchecked (- [ ] item)
      {
        re: /^([ \t]*[-*+])[ \t]+\[ \][ \t]+/gm,
        process: (match, start) => {
          const bulletMatch = match.match(/^[ \t]*[-*+]/)
          const bulletEnd = bulletMatch ? bulletMatch[0].length : 1
          markers.push(createRange(start, start + bulletEnd)) // bullet
          markers.push(createRange(start + bulletEnd, start + match.length)) // [ ]
        }
      },
      // Task lists checked (- [x] item)
      {
        re: /^([ \t]*[-*+])[ \t]+\[[xX]\][ \t]+(.*)$/gm,
        process: (match, start) => {
          const bulletMatch = match.match(/^[ \t]*[-*+]/)
          const bulletEnd = bulletMatch ? bulletMatch[0].length : 1
          const checkboxMatch = match.match(/^[ \t]*[-*+][ \t]+\[[xX]\][ \t]+/)
          const checkboxEnd = checkboxMatch ? checkboxMatch[0].length : bulletEnd + 5
          markers.push(createRange(start, start + checkboxEnd)) // bullet + [x] + space
          if (match.length > checkboxEnd) {
            taskDone.push(createRange(start + checkboxEnd, start + match.length)) // content
          }
        }
      }
    ]

    // Process each pattern
    for (const {re, process} of patterns) {
      re.lastIndex = 0
      let match
      while ((match = re.exec(text)) !== null) {
        try {
          process(match[0], match.index, match)
        } catch (e) {
          // Skip invalid ranges
        }
      }
    }

    // Register highlights (filter out any null ranges)
    const validMarkers = markers.filter(Boolean)
    const validBold = bold.filter(Boolean)
    const validItalic = italic.filter(Boolean)
    const validCode = code.filter(Boolean)
    const validStrike = strike.filter(Boolean)
    const validHeading = heading.filter(Boolean)
    const validLink = link.filter(Boolean)
    const validCodeblock = codeblock.filter(Boolean)
    const validBlockquote = blockquote.filter(Boolean)
    const validHr = hr.filter(Boolean)
    const validTaskDone = taskDone.filter(Boolean)

    if (validMarkers.length) CSS.highlights.set('md-marker', new Highlight(...validMarkers))
    if (validBold.length) CSS.highlights.set('md-bold', new Highlight(...validBold))
    if (validItalic.length) CSS.highlights.set('md-italic', new Highlight(...validItalic))
    if (validCode.length) CSS.highlights.set('md-code', new Highlight(...validCode))
    if (validStrike.length) CSS.highlights.set('md-strike', new Highlight(...validStrike))
    if (validHeading.length) CSS.highlights.set('md-heading', new Highlight(...validHeading))
    if (validLink.length) CSS.highlights.set('md-link', new Highlight(...validLink))
    if (validCodeblock.length) CSS.highlights.set('md-codeblock', new Highlight(...validCodeblock))
    if (validBlockquote.length) CSS.highlights.set('md-blockquote', new Highlight(...validBlockquote))
    if (validHr.length) CSS.highlights.set('md-hr', new Highlight(...validHr))
    if (validTaskDone.length) CSS.highlights.set('md-task-done', new Highlight(...validTaskDone))
  }

  async function download() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }
</script>
