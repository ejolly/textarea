<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    background-color: #fff;
    color: #161616;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      color: #fff;
    }
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100vh;
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  /* Markdown content styling via CSS Custom Highlight API
     Note: Only color, background-color, and text-decoration are supported.
     Properties like font-weight, font-style, font-family, opacity are ignored. */
  ::highlight(md-bold) {
    color: #953800;
    @media (prefers-color-scheme: dark) {
      color: #ffa657;
    }
  }

  ::highlight(md-italic) {
    color: #6639ba;
    @media (prefers-color-scheme: dark) {
      color: #d2a8ff;
    }
  }

  ::highlight(md-code) {
    background-color: rgba(128, 128, 128, 0.2);
  }

  ::highlight(md-strike) {
    text-decoration: line-through;
  }

  ::highlight(md-heading) {
    color: #0550ae;
    @media (prefers-color-scheme: dark) {
      color: #58a6ff;
    }
  }

  ::highlight(md-link) {
    color: #0969da;
    text-decoration: underline;
    @media (prefers-color-scheme: dark) {
      color: #58a6ff;
    }
  }

  ::highlight(md-codeblock) {
    background-color: rgba(128, 128, 128, 0.15);
  }

  /* Dimmed markers - use transparent color since opacity is not supported */
  ::highlight(md-marker) {
    color: rgba(128, 128, 128, 0.5);
  }

  ::highlight(md-blockquote) {
    color: #57606a;
    @media (prefers-color-scheme: dark) {
      color: #8b949e;
    }
  }

  ::highlight(md-hr) {
    color: rgba(128, 128, 128, 0.4);
  }

  ::highlight(md-task-done) {
    text-decoration: line-through;
    color: rgba(128, 128, 128, 0.6);
  }
</style>
<article contenteditable="plaintext-only" spellcheck></article>
<script>
  const article = document.querySelector('article')
  article.addEventListener('input', debounce(300, onInput))
  article.addEventListener('blur', save)
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault()
      download()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  // Check for CSS Custom Highlight API support
  const hasHighlightAPI = 'CSS' in window && 'highlights' in CSS

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
        article.focus()
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
      article.focus()
    }
    updateTitle()
    if (hasHighlightAPI) highlightMarkdown()
  }

  function onInput() {
    save()
    if (hasHighlightAPI) highlightMarkdown()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try { localStorage.setItem('hash', hash) } catch (e) {}
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    article.textContent = content
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1]?.trim() ?? 'Textarea'
  }

  // Compression: Brotli with fallback to deflate-raw
  // Format: prefix byte ('0' = deflate-raw, '1' = brotli) + base64url encoded data
  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    let format = 'deflate-raw', prefix = '0'

    // Try Brotli if available
    try {
      new CompressionStream('br')
      format = 'br'
      prefix = '1'
    } catch {}

    const stream = new CompressionStream(format)
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return prefix + new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(data) {
    if (!data) return ''

    // Detect format from prefix
    let format = 'deflate-raw'
    let encoded = data

    if (data[0] === '1') {
      format = 'br'
      encoded = data.slice(1)
    } else if (data[0] === '0') {
      format = 'deflate-raw'
      encoded = data.slice(1)
    }
    // No prefix = legacy deflate-raw format (backwards compatibility)

    const byteArray = Uint8Array.fromBase64(encoded, {alphabet: 'base64url'})
    const stream = new DecompressionStream(format)
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  // CSS Custom Highlight API for markdown rendering
  function highlightMarkdown() {
    // Clear existing highlights
    CSS.highlights.clear()

    // Build text and position map, accounting for <br> elements
    // which contribute newlines visually but not in textContent
    const nodePositions = []
    let text = ''

    function walkNodes(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        nodePositions.push({ node, start: text.length, end: text.length + node.length, type: 'text' })
        text += node.textContent
      } else if (node.nodeName === 'BR') {
        // BR elements contribute a newline to the logical text
        nodePositions.push({ node, start: text.length, end: text.length + 1, type: 'br' })
        text += '\n'
      } else if (node.childNodes) {
        for (const child of node.childNodes) {
          walkNodes(child)
        }
      }
    }
    walkNodes(article)

    if (!text || !nodePositions.length) return

    // Helper to find node and offset for a given text position
    function findPosition(pos) {
      for (let i = 0; i < nodePositions.length; i++) {
        const np = nodePositions[i]
        if (pos >= np.start && pos < np.end) {
          if (np.type === 'br') {
            // Position falls on a BR newline - use end of previous text node
            for (let j = i - 1; j >= 0; j--) {
              if (nodePositions[j].type === 'text') {
                return { node: nodePositions[j].node, offset: nodePositions[j].node.length }
              }
            }
            // No previous text node, use start of next text node
            for (let j = i + 1; j < nodePositions.length; j++) {
              if (nodePositions[j].type === 'text') {
                return { node: nodePositions[j].node, offset: 0 }
              }
            }
          }
          return { node: np.node, offset: pos - np.start }
        }
        // Handle position at exact end of this node
        if (pos === np.end && np.type === 'text') {
          return { node: np.node, offset: np.node.length }
        }
      }
      // Fallback to end of last text node
      for (let i = nodePositions.length - 1; i >= 0; i--) {
        if (nodePositions[i].type === 'text') {
          return { node: nodePositions[i].node, offset: nodePositions[i].node.length }
        }
      }
      return null
    }

    // Create range that works across multiple text nodes
    function createRange(startPos, endPos) {
      const range = new Range()
      const startInfo = findPosition(startPos)
      const endInfo = findPosition(endPos)
      if (!startInfo || !endInfo) return null
      range.setStart(startInfo.node, startInfo.offset)
      range.setEnd(endInfo.node, endInfo.offset)
      return range
    }

    // Highlight collections
    const markers = []
    const bold = []
    const italic = []
    const code = []
    const strike = []
    const heading = []
    const link = []
    const codeblock = []
    const blockquote = []
    const hr = []
    const taskDone = []

    // Patterns with capture groups for markers vs content
    const patterns = [
      // Code blocks (``` ... ```)
      {
        re: /```[^\n]*\n[\s\S]*?\n```/g,
        process: (match, start) => {
          const end = start + match.length
          const firstNewline = match.indexOf('\n') + 1
          const lastNewline = match.lastIndexOf('\n')
          // Opening ```
          markers.push(createRange(start, start + firstNewline))
          // Content
          if (lastNewline > firstNewline) {
            codeblock.push(createRange(start + firstNewline, start + lastNewline))
          }
          // Closing ```
          markers.push(createRange(start + lastNewline, end))
        }
      },
      // Inline code
      {
        re: /`([^`\n]+)`/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 1))
          code.push(createRange(start + 1, start + match.length - 1))
          markers.push(createRange(start + match.length - 1, start + match.length))
        }
      },
      // Bold **text**
      {
        re: /\*\*([^*\n]+?)\*\*/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 2))
          bold.push(createRange(start + 2, start + match.length - 2))
          markers.push(createRange(start + match.length - 2, start + match.length))
        }
      },
      // Strikethrough ~~text~~
      {
        re: /~~([^~\n]+?)~~/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 2))
          strike.push(createRange(start + 2, start + match.length - 2))
          markers.push(createRange(start + match.length - 2, start + match.length))
        }
      },
      // Italic *text* (but not **)
      {
        re: /(?<!\*)\*([^*\n]+?)\*(?!\*)/g,
        process: (match, start) => {
          markers.push(createRange(start, start + 1))
          italic.push(createRange(start + 1, start + match.length - 1))
          markers.push(createRange(start + match.length - 1, start + match.length))
        }
      },
      // Headings # text
      {
        re: /^(#{1,6})[ \t]+(.*)$/gm,
        process: (match, start) => {
          const hashMatch = match.match(/^#{1,6}[ \t]/)
          const hashEnd = hashMatch ? hashMatch[0].length : match.indexOf(' ') + 1
          markers.push(createRange(start, start + hashEnd))
          heading.push(createRange(start + hashEnd, start + match.length))
        }
      },
      // Links [text](url)
      {
        re: /\[([^\]\n]+?)\]\(([^)\n]+?)\)/g,
        process: (match, start) => {
          const bracketEnd = match.indexOf(']')
          markers.push(createRange(start, start + 1)) // [
          link.push(createRange(start + 1, start + bracketEnd)) // text
          markers.push(createRange(start + bracketEnd, start + match.length)) // ](url)
        }
      },
      // Images ![alt](url)
      {
        re: /!\[([^\]\n]*?)\]\(([^)\n]+?)\)/g,
        process: (match, start) => {
          const bracketEnd = match.indexOf(']')
          markers.push(createRange(start, start + 2)) // ![
          link.push(createRange(start + 2, start + bracketEnd)) // alt text
          markers.push(createRange(start + bracketEnd, start + match.length)) // ](url)
        }
      },
      // Blockquotes > text
      {
        re: /^(>+)[ \t]?(.*)$/gm,
        process: (match, start) => {
          const markerMatch = match.match(/^>+[ \t]?/)
          const markerEnd = markerMatch ? markerMatch[0].length : 1
          markers.push(createRange(start, start + markerEnd))
          if (match.length > markerEnd) {
            blockquote.push(createRange(start + markerEnd, start + match.length))
          }
        }
      },
      // Horizontal rules (---, ***, ___)
      {
        re: /^[ \t]*([-*_])\1{2,}[ \t]*$/gm,
        process: (match, start) => {
          hr.push(createRange(start, start + match.length))
        }
      },
      // Unordered lists (- item, * item, + item)
      {
        re: /^([ \t]*)([-*+])[ \t]+/gm,
        process: (match, start) => {
          const indentMatch = match.match(/^[ \t]*/)
          const indent = indentMatch ? indentMatch[0].length : 0
          markers.push(createRange(start + indent, start + indent + 1)) // bullet
        }
      },
      // Ordered lists (1. item)
      {
        re: /^([ \t]*)(\d+\.)[ \t]+/gm,
        process: (match, start) => {
          const indentMatch = match.match(/^[ \t]*/)
          const indent = indentMatch ? indentMatch[0].length : 0
          const numMatch = match.match(/\d+\./)
          const numLen = numMatch ? numMatch[0].length : 2
          markers.push(createRange(start + indent, start + indent + numLen)) // number.
        }
      },
      // Task lists unchecked (- [ ] item)
      {
        re: /^([ \t]*[-*+])[ \t]+\[ \][ \t]+/gm,
        process: (match, start) => {
          const bulletMatch = match.match(/^[ \t]*[-*+]/)
          const bulletEnd = bulletMatch ? bulletMatch[0].length : 1
          markers.push(createRange(start, start + bulletEnd)) // bullet
          markers.push(createRange(start + bulletEnd, start + match.length)) // [ ]
        }
      },
      // Task lists checked (- [x] item)
      {
        re: /^([ \t]*[-*+])[ \t]+\[[xX]\][ \t]+(.*)$/gm,
        process: (match, start) => {
          const bulletMatch = match.match(/^[ \t]*[-*+]/)
          const bulletEnd = bulletMatch ? bulletMatch[0].length : 1
          const checkboxMatch = match.match(/^[ \t]*[-*+][ \t]+\[[xX]\][ \t]+/)
          const checkboxEnd = checkboxMatch ? checkboxMatch[0].length : bulletEnd + 5
          markers.push(createRange(start, start + checkboxEnd)) // bullet + [x] + space
          if (match.length > checkboxEnd) {
            taskDone.push(createRange(start + checkboxEnd, start + match.length)) // content
          }
        }
      }
    ]

    // Process each pattern
    for (const {re, process} of patterns) {
      re.lastIndex = 0
      let match
      while ((match = re.exec(text)) !== null) {
        try {
          process(match[0], match.index, match)
        } catch (e) {
          // Skip invalid ranges
        }
      }
    }

    // Register highlights (filter out any null ranges)
    const validMarkers = markers.filter(Boolean)
    const validBold = bold.filter(Boolean)
    const validItalic = italic.filter(Boolean)
    const validCode = code.filter(Boolean)
    const validStrike = strike.filter(Boolean)
    const validHeading = heading.filter(Boolean)
    const validLink = link.filter(Boolean)
    const validCodeblock = codeblock.filter(Boolean)
    const validBlockquote = blockquote.filter(Boolean)
    const validHr = hr.filter(Boolean)
    const validTaskDone = taskDone.filter(Boolean)

    if (validMarkers.length) CSS.highlights.set('md-marker', new Highlight(...validMarkers))
    if (validBold.length) CSS.highlights.set('md-bold', new Highlight(...validBold))
    if (validItalic.length) CSS.highlights.set('md-italic', new Highlight(...validItalic))
    if (validCode.length) CSS.highlights.set('md-code', new Highlight(...validCode))
    if (validStrike.length) CSS.highlights.set('md-strike', new Highlight(...validStrike))
    if (validHeading.length) CSS.highlights.set('md-heading', new Highlight(...validHeading))
    if (validLink.length) CSS.highlights.set('md-link', new Highlight(...validLink))
    if (validCodeblock.length) CSS.highlights.set('md-codeblock', new Highlight(...validCodeblock))
    if (validBlockquote.length) CSS.highlights.set('md-blockquote', new Highlight(...validBlockquote))
    if (validHr.length) CSS.highlights.set('md-hr', new Highlight(...validHr))
    if (validTaskDone.length) CSS.highlights.set('md-task-done', new Highlight(...validTaskDone))
  }

  async function download() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }
</script>
