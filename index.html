<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    background-color: #fff;
    color: #161616;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      color: #fff;
    }
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100vh;
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  /* Markdown content styling via CSS Custom Highlight API */
  ::highlight(md-bold) {
    font-weight: bold;
  }

  ::highlight(md-italic) {
    font-style: italic;
  }

  ::highlight(md-code) {
    font-family: ui-monospace, monospace;
    background-color: rgba(128, 128, 128, 0.15);
    border-radius: 3px;
  }

  ::highlight(md-strike) {
    text-decoration: line-through;
  }

  ::highlight(md-heading) {
    font-weight: bold;
  }

  ::highlight(md-link) {
    color: #0969da;
    text-decoration: underline;
    @media (prefers-color-scheme: dark) {
      color: #58a6ff;
    }
  }

  ::highlight(md-codeblock) {
    font-family: ui-monospace, monospace;
    background-color: rgba(128, 128, 128, 0.15);
  }

  /* Dimmed markers */
  ::highlight(md-marker) {
    opacity: 0.3;
  }
</style>
<article contenteditable="plaintext-only" spellcheck></article>
<script>
  const article = document.querySelector('article')
  article.addEventListener('input', debounce(300, onInput))
  article.addEventListener('blur', save)
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault()
      download()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  // Check for CSS Custom Highlight API support
  const hasHighlightAPI = 'CSS' in window && 'highlights' in CSS

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
        article.focus()
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
      article.focus()
    }
    updateTitle()
    if (hasHighlightAPI) highlightMarkdown()
  }

  function onInput() {
    save()
    if (hasHighlightAPI) highlightMarkdown()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try { localStorage.setItem('hash', hash) } catch (e) {}
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    article.textContent = content
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1]?.trim() ?? 'Textarea'
  }

  // Compression: Brotli with fallback to deflate-raw
  // Format: prefix byte ('0' = deflate-raw, '1' = brotli) + base64url encoded data
  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    let format = 'deflate-raw', prefix = '0'

    // Try Brotli if available
    try {
      new CompressionStream('br')
      format = 'br'
      prefix = '1'
    } catch {}

    const stream = new CompressionStream(format)
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return prefix + new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(data) {
    if (!data) return ''

    // Detect format from prefix
    let format = 'deflate-raw'
    let encoded = data

    if (data[0] === '1') {
      format = 'br'
      encoded = data.slice(1)
    } else if (data[0] === '0') {
      format = 'deflate-raw'
      encoded = data.slice(1)
    }
    // No prefix = legacy deflate-raw format (backwards compatibility)

    const byteArray = Uint8Array.fromBase64(encoded, {alphabet: 'base64url'})
    const stream = new DecompressionStream(format)
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  // CSS Custom Highlight API for markdown rendering
  function highlightMarkdown() {
    // Clear existing highlights
    CSS.highlights.clear()

    const text = article.textContent
    if (!text) return

    // Get the text node(s) - normalize to ensure single text node
    article.normalize()
    const textNode = article.firstChild
    if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return

    // Highlight collections
    const markers = []
    const bold = []
    const italic = []
    const code = []
    const strike = []
    const heading = []
    const link = []
    const codeblock = []

    // Patterns with capture groups for markers vs content
    const patterns = [
      // Code blocks (``` ... ```)
      {
        re: /```[^\n]*\n[\s\S]*?\n```/g,
        process: (match, start) => {
          const end = start + match.length
          const firstNewline = match.indexOf('\n') + 1
          const lastNewline = match.lastIndexOf('\n')
          // Opening ```
          markers.push(createRange(textNode, start, start + firstNewline))
          // Content
          if (lastNewline > firstNewline) {
            codeblock.push(createRange(textNode, start + firstNewline, start + lastNewline))
          }
          // Closing ```
          markers.push(createRange(textNode, start + lastNewline, end))
        }
      },
      // Inline code
      {
        re: /`([^`\n]+)`/g,
        process: (match, start, groups) => {
          markers.push(createRange(textNode, start, start + 1))
          code.push(createRange(textNode, start + 1, start + match.length - 1))
          markers.push(createRange(textNode, start + match.length - 1, start + match.length))
        }
      },
      // Bold **text**
      {
        re: /\*\*([^*\n]+?)\*\*/g,
        process: (match, start) => {
          markers.push(createRange(textNode, start, start + 2))
          bold.push(createRange(textNode, start + 2, start + match.length - 2))
          markers.push(createRange(textNode, start + match.length - 2, start + match.length))
        }
      },
      // Strikethrough ~~text~~
      {
        re: /~~([^~\n]+?)~~/g,
        process: (match, start) => {
          markers.push(createRange(textNode, start, start + 2))
          strike.push(createRange(textNode, start + 2, start + match.length - 2))
          markers.push(createRange(textNode, start + match.length - 2, start + match.length))
        }
      },
      // Italic *text* (but not **)
      {
        re: /(?<!\*)\*([^*\n]+?)\*(?!\*)/g,
        process: (match, start) => {
          markers.push(createRange(textNode, start, start + 1))
          italic.push(createRange(textNode, start + 1, start + match.length - 1))
          markers.push(createRange(textNode, start + match.length - 1, start + match.length))
        }
      },
      // Headings # text
      {
        re: /^(#{1,6})[ \t]+(.*)$/gm,
        process: (match, start) => {
          const hashEnd = match.indexOf(' ')
          markers.push(createRange(textNode, start, start + hashEnd + 1))
          heading.push(createRange(textNode, start + hashEnd + 1, start + match.length))
        }
      },
      // Links [text](url)
      {
        re: /\[([^\]\n]+?)\]\(([^)\n]+?)\)/g,
        process: (match, start) => {
          const bracketEnd = match.indexOf(']')
          markers.push(createRange(textNode, start, start + 1)) // [
          link.push(createRange(textNode, start + 1, start + bracketEnd)) // text
          markers.push(createRange(textNode, start + bracketEnd, start + match.length)) // ](url)
        }
      }
    ]

    // Process each pattern
    for (const {re, process} of patterns) {
      re.lastIndex = 0
      let match
      while ((match = re.exec(text)) !== null) {
        try {
          process(match[0], match.index, match)
        } catch (e) {
          // Skip invalid ranges
        }
      }
    }

    // Register highlights
    if (markers.length) CSS.highlights.set('md-marker', new Highlight(...markers))
    if (bold.length) CSS.highlights.set('md-bold', new Highlight(...bold))
    if (italic.length) CSS.highlights.set('md-italic', new Highlight(...italic))
    if (code.length) CSS.highlights.set('md-code', new Highlight(...code))
    if (strike.length) CSS.highlights.set('md-strike', new Highlight(...strike))
    if (heading.length) CSS.highlights.set('md-heading', new Highlight(...heading))
    if (link.length) CSS.highlights.set('md-link', new Highlight(...link))
    if (codeblock.length) CSS.highlights.set('md-codeblock', new Highlight(...codeblock))
  }

  function createRange(node, start, end) {
    const range = new Range()
    range.setStart(node, start)
    range.setEnd(node, end)
    return range
  }

  async function download() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }
</script>
